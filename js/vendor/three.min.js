(function(global){
    if(!global) {
        throw new Error('Global scope is required for Three.js stub.');
    }
    if(global.THREE && global.THREE.__CODEx_STUB__) {
        return;
    }
    const THREE = {};

    function isNumber(value){
        return typeof value === 'number' && isFinite(value);
    }

    class EventDispatcher {
        constructor(){
            this._listeners = {};
        }
        addEventListener(type, listener){
            if(typeof listener !== 'function'){
                return;
            }
            if(!this._listeners[type]){
                this._listeners[type] = [];
            }
            if(this._listeners[type].indexOf(listener) === -1){
                this._listeners[type].push(listener);
            }
        }
        removeEventListener(type, listener){
            const listeners = this._listeners[type];
            if(!listeners){
                return;
            }
            const index = listeners.indexOf(listener);
            if(index !== -1){
                listeners.splice(index, 1);
            }
        }
        dispatchEvent(event){
            if(!event || !event.type){
                return;
            }
            const listeners = this._listeners[event.type];
            if(!listeners || listeners.length === 0){
                return;
            }
            const array = listeners.slice();
            for(let i=0;i<array.length;i++){
                try {
                    array[i].call(this, event);
                } catch(err){
                    setTimeout(()=>{ throw err; });
                }
            }
        }
    }

    class Vector3 {
        constructor(x=0, y=0, z=0){
            this.x = x;
            this.y = y;
            this.z = z;
        }
        set(x, y, z){
            this.x = x;
            this.y = y;
            this.z = z;
            return this;
        }
        copy(v){
            if(v){
                this.x = v.x;
                this.y = v.y;
                this.z = v.z;
            }
            return this;
        }
        clone(){
            return new Vector3(this.x, this.y, this.z);
        }
        add(v){
            this.x += v.x;
            this.y += v.y;
            this.z += v.z;
            return this;
        }
        sub(v){
            this.x -= v.x;
            this.y -= v.y;
            this.z -= v.z;
            return this;
        }
        subVectors(a, b){
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            this.z = a.z - b.z;
            return this;
        }
        multiplyScalar(s){
            this.x *= s;
            this.y *= s;
            this.z *= s;
            return this;
        }
        length(){
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        normalize(){
            const len = this.length();
            if(len > 0){
                this.multiplyScalar(1 / len);
            }
            return this;
        }
        distanceTo(v){
            const dx = this.x - v.x;
            const dy = this.y - v.y;
            const dz = this.z - v.z;
            return Math.sqrt(dx * dx + dy * dy + dz * dz);
        }
        negate(){
            this.x = -this.x;
            this.y = -this.y;
            this.z = -this.z;
            return this;
        }
        addScalar(s){
            this.x += s;
            this.y += s;
            this.z += s;
            return this;
        }
        addVectors(a, b){
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            this.z = a.z + b.z;
            return this;
        }
        lerp(v, alpha){
            this.x += (v.x - this.x) * alpha;
            this.y += (v.y - this.y) * alpha;
            this.z += (v.z - this.z) * alpha;
            return this;
        }
    }

    class Vector2 {
        constructor(x=0, y=0){
            this.x = x;
            this.y = y;
        }
        set(x, y){
            this.x = x;
            this.y = y;
            return this;
        }
        copy(v){
            if(v){
                this.x = v.x;
                this.y = v.y;
            }
            return this;
        }
        clone(){
            return new Vector2(this.x, this.y);
        }
    }

    class Euler {
        constructor(x=0, y=0, z=0){
            this.x = x;
            this.y = y;
            this.z = z;
        }
        set(x, y, z){
            this.x = x;
            this.y = y;
            this.z = z;
            return this;
        }
        copy(euler){
            if(euler){
                this.x = euler.x;
                this.y = euler.y;
                this.z = euler.z;
            }
            return this;
        }
        clone(){
            return new Euler(this.x, this.y, this.z);
        }
    }

    class Color {
        constructor(hex=0xffffff){
            this.setHex(hex);
        }
        set(hex){
            if(hex instanceof Color){
                this.r = hex.r;
                this.g = hex.g;
                this.b = hex.b;
            } else if(typeof hex === 'number'){
                this.setHex(hex);
            }
            return this;
        }
        setHex(hex){
            const value = isNumber(hex) ? hex : 0xffffff;
            this.r = ((value >> 16) & 255) / 255;
            this.g = ((value >> 8) & 255) / 255;
            this.b = (value & 255) / 255;
            return this;
        }
        copy(color){
            if(color){
                this.r = color.r;
                this.g = color.g;
                this.b = color.b;
            }
            return this;
        }
        clone(){
            const c = new Color();
            c.r = this.r;
            c.g = this.g;
            c.b = this.b;
            return c;
        }
    }

    class Object3D extends EventDispatcher {
        constructor(){
            super();
            this.children = [];
            this.parent = null;
            this.position = new Vector3();
            this.rotation = new Euler();
            this.scale = new Vector3(1, 1, 1);
            this.userData = {};
            this.name = '';
        }
        add(object){
            if(!object || object === this){
                return;
            }
            if(object.parent){
                object.parent.remove(object);
            }
            object.parent = this;
            this.children.push(object);
        }
        remove(object){
            const index = this.children.indexOf(object);
            if(index !== -1){
                this.children.splice(index, 1);
                object.parent = null;
            }
        }
        traverse(callback){
            callback(this);
            for(let i=0;i<this.children.length;i++){
                this.children[i].traverse(callback);
            }
        }
        getWorldPosition(target){
            const result = target || new Vector3();
            result.copy(this.position);
            let current = this.parent;
            while(current){
                result.add(current.position);
                current = current.parent;
            }
            return result;
        }
        lookAt(){
            // Stub: no-op
        }
        clone(){
            const clone = new Object3D();
            clone.position.copy(this.position);
            clone.rotation.copy(this.rotation);
            clone.scale.copy(this.scale);
            clone.userData = JSON.parse(JSON.stringify(this.userData || {}));
            return clone;
        }
    }

    class Group extends Object3D {
        constructor(){
            super();
        }
    }

    class Scene extends Object3D {
        constructor(){
            super();
            this.fog = null;
        }
    }

    class FogExp2 {
        constructor(color, density){
            this.color = new Color(color);
            this.density = density || 0.00025;
        }
    }

    class Camera extends Object3D {
        constructor(){
            super();
        }
    }

    class PerspectiveCamera extends Camera {
        constructor(fov=50, aspect=1, near=0.1, far=2000){
            super();
            this.isPerspectiveCamera = true;
            this.fov = fov;
            this.aspect = aspect;
            this.near = near;
            this.far = far;
        }
        updateProjectionMatrix(){
            // Stub: nothing to do
        }
    }

    class Material {
        constructor(params={}){
            this.transparent = !!params.transparent;
            this.opacity = isNumber(params.opacity) ? params.opacity : 1;
            this.depthTest = params.depthTest !== undefined ? params.depthTest : true;
            this.depthWrite = params.depthWrite !== undefined ? params.depthWrite : true;
            this.side = params.side !== undefined ? params.side : THREE.FrontSide;
        }
        dispose(){
            // noop
        }
    }

    class MeshBasicMaterial extends Material {
        constructor(params={}){
            super(params);
            this.color = new Color(params.color !== undefined ? params.color : 0xffffff);
        }
    }

    class MeshStandardMaterial extends Material {
        constructor(params={}){
            super(params);
            this.color = new Color(params.color !== undefined ? params.color : 0xffffff);
            this.emissive = new Color(params.emissive !== undefined ? params.emissive : 0x000000);
            this.emissiveIntensity = isNumber(params.emissiveIntensity) ? params.emissiveIntensity : 1;
            this.roughness = isNumber(params.roughness) ? params.roughness : 1;
            this.metalness = isNumber(params.metalness) ? params.metalness : 0;
        }
    }

    class SpriteMaterial extends Material {
        constructor(params={}){
            super(params);
            this.map = params.map || null;
        }
    }

    class Texture {
        constructor(image){
            this.image = image || null;
            this.needsUpdate = false;
        }
        dispose(){
            this.image = null;
        }
    }

    class CanvasTexture extends Texture {
        constructor(canvas){
            super(canvas);
            this.minFilter = THREE.LinearFilter;
            this.encoding = THREE.LinearEncoding;
        }
    }

    class Geometry {
        constructor(){
            this.parameters = {};
        }
    }

    class SphereGeometry extends Geometry {
        constructor(radius=1){
            super();
            this.parameters.radius = radius;
        }
    }

    class RingGeometry extends Geometry {
        constructor(innerRadius=0, outerRadius=1, thetaSegments=8){
            super();
            this.parameters.innerRadius = innerRadius;
            this.parameters.outerRadius = outerRadius;
            this.parameters.thetaSegments = thetaSegments;
        }
    }

    class IcosahedronGeometry extends Geometry {
        constructor(radius=1, detail=0){
            super();
            this.parameters.radius = radius;
            this.parameters.detail = detail;
        }
    }

    class Object3DWithMaterial extends Object3D {
        constructor(){
            super();
            this.material = null;
        }
    }

    class Mesh extends Object3DWithMaterial {
        constructor(geometry, material){
            super();
            this.geometry = geometry || new Geometry();
            this.material = material || new Material();
        }
    }

    class Sprite extends Object3DWithMaterial {
        constructor(material){
            super();
            this.material = material || new SpriteMaterial();
        }
    }

    class Light extends Object3D {
        constructor(color=0xffffff, intensity=1){
            super();
            this.color = new Color(color);
            this.intensity = intensity;
        }
    }

    class AmbientLight extends Light {
        constructor(color, intensity){
            super(color, intensity);
        }
    }

    class DirectionalLight extends Light {
        constructor(color, intensity){
            super(color, intensity);
            this.position = new Vector3();
        }
    }

    class PointLight extends Light {
        constructor(color, intensity, distance){
            super(color, intensity);
            this.distance = distance !== undefined ? distance : 0;
            this.position = new Vector3();
        }
    }

    class Raycaster {
        constructor(){
            this.ray = {
                origin: new Vector3(),
                direction: new Vector3(0, 0, -1)
            };
        }
        setFromCamera(coords, camera){
            this.ray.origin.set(0, 0, 0);
            if(camera && camera.position){
                this.ray.origin.copy(camera.position);
            }
            this.ray.direction.set(coords.x || 0, coords.y || 0, -1).normalize();
        }
        intersectObjects(){
            return [];
        }
    }

    class WebGLRenderer {
        constructor(params={}){
            this.parameters = params;
            this.domElement = (typeof document !== 'undefined') ? document.createElement('canvas') : { style: {}, addEventListener(){}, removeEventListener(){} };
            this.outputEncoding = THREE.LinearEncoding;
            this._pixelRatio = 1;
            this._clearColor = { color: 0x000000, alpha: 1 };
        }
        setSize(width, height){
            if(this.domElement){
                this.domElement.width = width;
                this.domElement.height = height;
                if(this.domElement.style){
                    this.domElement.style.width = width + 'px';
                    this.domElement.style.height = height + 'px';
                }
            }
        }
        setPixelRatio(ratio){
            this._pixelRatio = ratio;
        }
        setClearColor(color, alpha){
            this._clearColor = { color, alpha };
        }
        render(){
            // Stub: no-op
        }
        dispose(){
            // Stub: no-op
        }
    }

    THREE.EventDispatcher = EventDispatcher;
    THREE.Vector3 = Vector3;
    THREE.Vector2 = Vector2;
    THREE.Euler = Euler;
    THREE.Color = Color;
    THREE.Object3D = Object3D;
    THREE.Group = Group;
    THREE.Scene = Scene;
    THREE.FogExp2 = FogExp2;
    THREE.Camera = Camera;
    THREE.PerspectiveCamera = PerspectiveCamera;
    THREE.Material = Material;
    THREE.MeshBasicMaterial = MeshBasicMaterial;
    THREE.MeshStandardMaterial = MeshStandardMaterial;
    THREE.SpriteMaterial = SpriteMaterial;
    THREE.Texture = Texture;
    THREE.CanvasTexture = CanvasTexture;
    THREE.Geometry = Geometry;
    THREE.SphereGeometry = SphereGeometry;
    THREE.RingGeometry = RingGeometry;
    THREE.IcosahedronGeometry = IcosahedronGeometry;
    THREE.Mesh = Mesh;
    THREE.Sprite = Sprite;
    THREE.Light = Light;
    THREE.AmbientLight = AmbientLight;
    THREE.DirectionalLight = DirectionalLight;
    THREE.PointLight = PointLight;
    THREE.Raycaster = Raycaster;
    THREE.WebGLRenderer = WebGLRenderer;

    THREE.DoubleSide = 2;
    THREE.FrontSide = 0;
    THREE.BackSide = 1;
    THREE.LinearFilter = 'LinearFilter';
    THREE.LinearEncoding = 'LinearEncoding';
    THREE.sRGBEncoding = 'sRGBEncoding';

    THREE.__CODEx_STUB__ = true;

    if(!global.THREE){
        global.THREE = THREE;
    } else {
        for(const key of Object.keys(THREE)){
            global.THREE[key] = THREE[key];
        }
    }
})(typeof window !== 'undefined' ? window : (typeof globalThis !== 'undefined' ? globalThis : this));
