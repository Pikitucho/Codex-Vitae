(function(global){
    'use strict';

    if (!global) {
        throw new Error('Global scope is required for Three.js replacement.');
    }

    if (global.THREE) {
        return;
    }

    const THREE = {};
    THREE.__CODEx_CUSTOM__ = true;
    THREE.REVISION = 'CV-lite-1';

    const DEG2RAD = Math.PI / 180;
    const RAD2DEG = 180 / Math.PI;

    THREE.MathUtils = {
        DEG2RAD,
        RAD2DEG,
        clamp(value, min, max) {
            return Math.max(min, Math.min(max, value));
        },
        lerp(start, end, alpha) {
            return start + (end - start) * alpha;
        }
    };

    class Vector2 {
        constructor(x = 0, y = 0) {
            this.x = x;
            this.y = y;
        }
        set(x, y) {
            this.x = x;
            this.y = y;
            return this;
        }
        copy(v) {
            this.x = v.x;
            this.y = v.y;
            return this;
        }
        clone() {
            return new Vector2(this.x, this.y);
        }
        subVectors(a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            return this;
        }
    }

    class Vector3 {
        constructor(x = 0, y = 0, z = 0) {
            this.x = x;
            this.y = y;
            this.z = z;
        }
        set(x, y, z) {
            this.x = x;
            this.y = y;
            this.z = z;
            return this;
        }
        copy(v) {
            this.x = v.x;
            this.y = v.y;
            this.z = v.z;
            return this;
        }
        clone() {
            return new Vector3(this.x, this.y, this.z);
        }
        add(v) {
            this.x += v.x;
            this.y += v.y;
            this.z += v.z;
            return this;
        }
        addScalar(s) {
            this.x += s;
            this.y += s;
            this.z += s;
            return this;
        }
        addScaledVector(v, s) {
            this.x += v.x * s;
            this.y += v.y * s;
            this.z += v.z * s;
            return this;
        }
        sub(v) {
            this.x -= v.x;
            this.y -= v.y;
            this.z -= v.z;
            return this;
        }
        subVectors(a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            this.z = a.z - b.z;
            return this;
        }
        multiplyScalar(s) {
            this.x *= s;
            this.y *= s;
            this.z *= s;
            return this;
        }
        multiply(v) {
            this.x *= v.x;
            this.y *= v.y;
            this.z *= v.z;
            return this;
        }
        divideScalar(s) {
            if (s !== 0) {
                const inv = 1 / s;
                this.x *= inv;
                this.y *= inv;
                this.z *= inv;
            } else {
                this.x = 0;
                this.y = 0;
                this.z = 0;
            }
            return this;
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        normalize() {
            const len = this.length();
            if (len > 0) {
                this.divideScalar(len);
            }
            return this;
        }
        distanceTo(v) {
            return Math.sqrt(this.distanceToSquared(v));
        }
        distanceToSquared(v) {
            const dx = this.x - v.x;
            const dy = this.y - v.y;
            const dz = this.z - v.z;
            return dx * dx + dy * dy + dz * dz;
        }
        dot(v) {
            return this.x * v.x + this.y * v.y + this.z * v.z;
        }
        cross(v) {
            const x = this.y * v.z - this.z * v.y;
            const y = this.z * v.x - this.x * v.z;
            const z = this.x * v.y - this.y * v.x;
            this.x = x;
            this.y = y;
            this.z = z;
            return this;
        }
        crossVectors(a, b) {
            const x = a.y * b.z - a.z * b.y;
            const y = a.z * b.x - a.x * b.z;
            const z = a.x * b.y - a.y * b.x;
            this.x = x;
            this.y = y;
            this.z = z;
            return this;
        }
        negate() {
            this.x = -this.x;
            this.y = -this.y;
            this.z = -this.z;
            return this;
        }
        lerp(v, alpha) {
            this.x += (v.x - this.x) * alpha;
            this.y += (v.y - this.y) * alpha;
            this.z += (v.z - this.z) * alpha;
            return this;
        }
        setLength(length) {
            const oldLength = this.length();
            if (oldLength !== 0 && length !== oldLength) {
                this.multiplyScalar(length / oldLength);
            }
            return this;
        }
    }

    class Color {
        constructor(value = 0xffffff) {
            this.setHex(value);
        }
        setHex(hex) {
            const value = (typeof hex === 'number') ? hex : parseInt(hex.replace('#', ''), 16);
            this.r = ((value >> 16) & 255) / 255;
            this.g = ((value >> 8) & 255) / 255;
            this.b = (value & 255) / 255;
            return this;
        }
        setRGB(r, g, b) {
            this.r = r;
            this.g = g;
            this.b = b;
            return this;
        }
        copy(color) {
            this.r = color.r;
            this.g = color.g;
            this.b = color.b;
            return this;
        }
        clone() {
            const c = new Color();
            c.r = this.r;
            c.g = this.g;
            c.b = this.b;
            return c;
        }
        lerp(color, alpha = 0) {
            const target = color instanceof Color ? color : new Color(color ?? 0xffffff);
            const t = Number.isFinite(alpha) ? Math.max(0, Math.min(1, alpha)) : 0;
            this.r += (target.r - this.r) * t;
            this.g += (target.g - this.g) * t;
            this.b += (target.b - this.b) * t;
            return this;
        }
        add(color) {
            this.r += color.r;
            this.g += color.g;
            this.b += color.b;
            return this;
        }
        multiplyScalar(s) {
            this.r *= s;
            this.g *= s;
            this.b *= s;
            return this;
        }
        getStyle(alpha = 1) {
            const r = Math.round(THREE.MathUtils.clamp(this.r, 0, 1) * 255);
            const g = Math.round(THREE.MathUtils.clamp(this.g, 0, 1) * 255);
            const b = Math.round(THREE.MathUtils.clamp(this.b, 0, 1) * 255);
            return `rgba(${r}, ${g}, ${b}, ${THREE.MathUtils.clamp(alpha, 0, 1)})`;
        }
    }

    class EventDispatcher {
        constructor() {
            this._listeners = {};
        }
        addEventListener(type, listener) {
            if (typeof listener !== 'function') {
                return;
            }
            if (!this._listeners[type]) {
                this._listeners[type] = [];
            }
            if (this._listeners[type].indexOf(listener) === -1) {
                this._listeners[type].push(listener);
            }
        }
        removeEventListener(type, listener) {
            const listeners = this._listeners[type];
            if (!listeners) {
                return;
            }
            const index = listeners.indexOf(listener);
            if (index !== -1) {
                listeners.splice(index, 1);
            }
        }
        dispatchEvent(event) {
            if (!event || typeof event.type !== 'string') {
                return;
            }
            const listeners = this._listeners[event.type];
            if (!listeners || !listeners.length) {
                return;
            }
            listeners.slice().forEach(listener => listener.call(this, event));
        }
    }

    class Object3D extends EventDispatcher {
        constructor() {
            super();
            this.name = '';
            this.parent = null;
            this.children = [];
            this.position = new Vector3();
            this.scale = new Vector3(1, 1, 1);
            this.rotation = new Vector3();
            this.visible = true;
            this.userData = {};
            this.renderOrder = 0;
            this.matrixWorldNeedsUpdate = true;
        }
        add(object) {
            if (!object || object === this) {
                return;
            }
            if (object.parent) {
                object.parent.remove(object);
            }
            object.parent = this;
            this.children.push(object);
            this.matrixWorldNeedsUpdate = true;
        }
        remove(object) {
            const index = this.children.indexOf(object);
            if (index !== -1) {
                object.parent = null;
                this.children.splice(index, 1);
                this.matrixWorldNeedsUpdate = true;
            }
        }
        traverse(callback) {
            callback(this);
            this.children.forEach(child => child.traverse(callback));
        }
        getWorldPosition(target = new Vector3()) {
            target.copy(this.position);
            let parent = this.parent;
            while (parent) {
                target.add(parent.position);
                parent = parent.parent;
            }
            return target;
        }
        getWorldScale(target = new Vector3()) {
            target.copy(this.scale);
            let parent = this.parent;
            while (parent) {
                target.multiply(parent.scale);
                parent = parent.parent;
            }
            return target;
        }
    }

    class Scene extends Object3D {
        constructor() {
            super();
            this.fog = null;
            this.background = null;
        }
    }

    class Camera extends Object3D {
        constructor() {
            super();
            this.up = new Vector3(0, 1, 0);
            this.matrixWorldNeedsUpdate = true;
        }
    }

    class PerspectiveCamera extends Camera {
        constructor(fov = 50, aspect = 1, near = 0.1, far = 2000) {
            super();
            this.type = 'PerspectiveCamera';
            this.fov = fov;
            this.aspect = aspect;
            this.near = near;
            this.far = far;
            this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
            this._tanHalfFov = Math.tan((this.fov * DEG2RAD) / 2);
        }
    }

    class FogExp2 {
        constructor(color = 0xffffff, density = 0.00025) {
            this.color = new Color(color);
            this.density = density;
        }
    }

    class BufferAttribute {
        constructor(array, itemSize, normalized = false) {
            if (!array || typeof array.length !== 'number') {
                throw new Error('BufferAttribute requires a valid array.');
            }
            if (!Number.isFinite(itemSize) || itemSize <= 0) {
                throw new Error('BufferAttribute requires a positive itemSize.');
            }
            this.array = array;
            this.itemSize = itemSize;
            this.count = array.length / itemSize;
            this.normalized = normalized;
            this.needsUpdate = false;
        }
        setX(index, x) {
            this.array[index * this.itemSize] = x;
            return this;
        }
        setY(index, y) {
            this.array[index * this.itemSize + 1] = y;
            return this;
        }
        setZ(index, z) {
            this.array[index * this.itemSize + 2] = z;
            return this;
        }
        clone() {
            const array = this.array.slice ? this.array.slice(0) : new this.array.constructor(this.array);
            return new BufferAttribute(array, this.itemSize, this.normalized);
        }
        copyArray(array) {
            this.array.set(array);
            return this;
        }
    }

    class BufferGeometry {
        constructor() {
            this.attributes = {};
            this.boundingSphere = null;
            this._drawRange = { start: 0, count: Infinity };
        }
        setAttribute(name, attribute) {
            if (!(attribute instanceof BufferAttribute) && attribute && attribute.array && attribute.itemSize) {
                attribute = new BufferAttribute(attribute.array, attribute.itemSize, attribute.normalized || false);
            }
            if (!(attribute instanceof BufferAttribute)) {
                throw new Error('BufferGeometry.setAttribute expects a BufferAttribute.');
            }
            this.attributes[name] = attribute;
            return this;
        }
        getAttribute(name) {
            return this.attributes[name] || null;
        }
        deleteAttribute(name) {
            delete this.attributes[name];
            return this;
        }
        setDrawRange(start, count) {
            this._drawRange.start = start;
            this._drawRange.count = count;
            return this;
        }
        get drawRange() {
            return this._drawRange;
        }
        dispose() {
            this.attributes = {};
            this.boundingSphere = null;
        }
    }

    class Geometry {
        constructor() {
            this.parameters = {};
        }
    }

    class SphereGeometry extends Geometry {
        constructor(radius = 1) {
            super();
            this.type = 'SphereGeometry';
            this.parameters.radius = radius;
        }
    }

    class IcosahedronGeometry extends Geometry {
        constructor(radius = 1) {
            super();
            this.type = 'IcosahedronGeometry';
            this.parameters.radius = radius;
        }
    }

    class RingGeometry extends Geometry {
        constructor(innerRadius = 0.5, outerRadius = 1) {
            super();
            this.type = 'RingGeometry';
            this.parameters.innerRadius = innerRadius;
            this.parameters.outerRadius = outerRadius;
        }
    }

    class PlaneGeometry extends Geometry {
        constructor(width = 1, height = 1) {
            super();
            this.type = 'PlaneGeometry';
            this.parameters.width = width;
            this.parameters.height = height;
        }
    }

    class Material {
        constructor(params = {}) {
            this.transparent = !!params.transparent;
            this.opacity = (typeof params.opacity === 'number') ? params.opacity : 1;
            this.visible = true;
        }
    }

    class MeshStandardMaterial extends Material {
        constructor(params = {}) {
            super(params);
            this.color = new Color(params.color !== undefined ? params.color : 0xffffff);
            this.emissive = new Color(params.emissive !== undefined ? params.emissive : 0x000000);
            this.emissiveIntensity = params.emissiveIntensity !== undefined ? params.emissiveIntensity : 0;
            this.roughness = params.roughness !== undefined ? params.roughness : 1;
            this.metalness = params.metalness !== undefined ? params.metalness : 0;
        }
    }

    class MeshBasicMaterial extends Material {
        constructor(params = {}) {
            super(params);
            this.color = new Color(params.color !== undefined ? params.color : 0xffffff);
            this.side = params.side !== undefined ? params.side : THREE.FrontSide;
        }
    }

    class Texture {
        constructor(image = null) {
            this.image = image;
            this.needsUpdate = true;
            this.encoding = THREE.LinearEncoding;
        }
    }

    class CanvasTexture extends Texture {
        constructor(canvas) {
            super(canvas);
            this.minFilter = THREE.LinearFilter;
        }
    }

    class SpriteMaterial extends Material {
        constructor(params = {}) {
            super(params);
            this.map = params.map || null;
            this.depthTest = params.depthTest !== undefined ? params.depthTest : true;
            this.depthWrite = params.depthWrite !== undefined ? params.depthWrite : true;
        }
    }

    class PointsMaterial extends Material {
        constructor(params = {}) {
            super(params);
            this.size = params.size !== undefined ? params.size : 1;
            this.sizeAttenuation = params.sizeAttenuation !== undefined ? params.sizeAttenuation : true;
            this.color = new Color(params.color !== undefined ? params.color : 0xffffff);
            this.vertexColors = !!params.vertexColors;
            this.depthWrite = params.depthWrite !== undefined ? params.depthWrite : true;
        }
    }

    class Mesh extends Object3D {
        constructor(geometry = new Geometry(), material = new MeshBasicMaterial()) {
            super();
            this.type = 'Mesh';
            this.geometry = geometry;
            this.material = material;
            this.isMesh = true;
        }
    }

    class Points extends Object3D {
        constructor(geometry = new BufferGeometry(), material = new PointsMaterial()) {
            super();
            this.type = 'Points';
            this.geometry = geometry;
            this.material = material;
            this.isPoints = true;
        }
    }

    class Sprite extends Object3D {
        constructor(material = new SpriteMaterial()) {
            super();
            this.type = 'Sprite';
            this.material = material;
            this.center = new Vector2(0.5, 0.5);
            this.isSprite = true;
        }
    }

    class Group extends Object3D {
        constructor() {
            super();
            this.type = 'Group';
        }
    }

    class Light extends Object3D {
        constructor(color = 0xffffff, intensity = 1) {
            super();
            this.color = new Color(color);
            this.intensity = intensity;
        }
    }

    class AmbientLight extends Light {
        constructor(color = 0xffffff, intensity = 1) {
            super(color, intensity);
            this.type = 'AmbientLight';
        }
    }

    class DirectionalLight extends Light {
        constructor(color = 0xffffff, intensity = 1) {
            super(color, intensity);
            this.type = 'DirectionalLight';
            this.target = new Object3D();
        }
    }

    class PointLight extends Light {
        constructor(color = 0xffffff, intensity = 1, distance = 0) {
            super(color, intensity);
            this.type = 'PointLight';
            this.distance = distance;
        }
    }

    class Spherical {
        constructor(radius = 1, phi = 0, theta = 0) {
            this.radius = radius;
            this.phi = phi;
            this.theta = theta;
        }
        set(radius, phi, theta) {
            this.radius = radius;
            this.phi = phi;
            this.theta = theta;
            return this;
        }
        makeSafe() {
            const EPS = 1e-6;
            this.phi = THREE.MathUtils.clamp(this.phi, EPS, Math.PI - EPS);
            return this;
        }
        setFromVector3(v) {
            this.radius = v.length();
            if (this.radius === 0) {
                this.theta = 0;
                this.phi = 0;
            } else {
                this.theta = Math.atan2(v.x, v.z);
                this.phi = Math.acos(THREE.MathUtils.clamp(v.y / this.radius, -1, 1));
            }
            return this;
        }
    }

    THREE.Vector2 = Vector2;
    THREE.Vector3 = Vector3;
    THREE.Color = Color;
    THREE.EventDispatcher = EventDispatcher;
    THREE.Object3D = Object3D;
    THREE.Scene = Scene;
    THREE.Camera = Camera;
    THREE.PerspectiveCamera = PerspectiveCamera;
    THREE.FogExp2 = FogExp2;
    THREE.BufferAttribute = BufferAttribute;
    THREE.BufferGeometry = BufferGeometry;
    THREE.Geometry = Geometry;
    THREE.SphereGeometry = SphereGeometry;
    THREE.IcosahedronGeometry = IcosahedronGeometry;
    THREE.RingGeometry = RingGeometry;
    THREE.PlaneGeometry = PlaneGeometry;
    THREE.PlaneBufferGeometry = PlaneGeometry;
    THREE.Material = Material;
    THREE.MeshStandardMaterial = MeshStandardMaterial;
    THREE.MeshBasicMaterial = MeshBasicMaterial;
    THREE.Texture = Texture;
    THREE.CanvasTexture = CanvasTexture;
    THREE.SpriteMaterial = SpriteMaterial;
    THREE.PointsMaterial = PointsMaterial;
    THREE.Mesh = Mesh;
    THREE.Points = Points;
    THREE.Sprite = Sprite;
    THREE.Group = Group;
    THREE.AmbientLight = AmbientLight;
    THREE.DirectionalLight = DirectionalLight;
    THREE.PointLight = PointLight;
    THREE.Spherical = Spherical;

    THREE.FrontSide = 1;
    THREE.BackSide = 0;
    THREE.DoubleSide = 2;
    THREE.LinearFilter = 'linear';
    THREE.LinearEncoding = 'linear';
    THREE.sRGBEncoding = 'sRGB';

    class Raycaster {
        constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
            this.ray = {
                origin: origin.clone(),
                direction: direction.clone().normalize()
            };
            this.params = {};
            this._ndc = new Vector2();
        }
        setFromCamera(coords, camera) {
            this._ndc.copy(coords);
            this._camera = camera;
        }
        _flatten(objects, recursive, result) {
            if (!objects) {
                return;
            }
            if (Array.isArray(objects)) {
                objects.forEach(obj => this._flatten(obj, recursive, result));
                return;
            }
            if (objects.visible === false) {
                return;
            }
            result.push(objects);
            if (recursive && objects.children && objects.children.length) {
                objects.children.forEach(child => this._flatten(child, true, result));
            }
        }
        intersectObjects(objects, recursive = false) {
            const list = [];
            this._flatten(objects, recursive, list);
            const cache = THREE.__pickCache;
            if (!cache) {
                return [];
            }
            const hits = [];
            const pointer = this._ndc;
            list.forEach(object => {
                const entry = cache.get(object);
                if (!entry) {
                    return;
                }
                const dx = pointer.x - entry.ndcX;
                const dy = pointer.y - entry.ndcY;
                const distSq = dx * dx + dy * dy;
                if (entry.type === 'ring') {
                    if (entry.outerRadiusNDC <= 0) {
                        return;
                    }
                    const outerSq = entry.outerRadiusNDC * entry.outerRadiusNDC;
                    const innerSq = entry.innerRadiusNDC * entry.innerRadiusNDC;
                    if (distSq <= outerSq && distSq >= innerSq) {
                        hits.push({
                            distance: entry.distance,
                            point: entry.worldPosition.clone(),
                            object
                        });
                    }
                    return;
                }
                if (entry.radiusNDC <= 0) {
                    return;
                }
                if (distSq <= entry.radiusNDC * entry.radiusNDC) {
                    hits.push({
                        distance: entry.distance,
                        point: entry.worldPosition.clone(),
                        object
                    });
                }
            });
            hits.sort((a, b) => a.distance - b.distance);
            return hits;
        }
    }

    THREE.Raycaster = Raycaster;

    class WebGLRenderer {
        constructor(params = {}) {
            this.domElement = global.document ? global.document.createElement('canvas') : null;
            if (!this.domElement) {
                throw new Error('WebGLRenderer requires a DOM-capable environment.');
            }
            this.domElement.width = 300;
            this.domElement.height = 150;
            this.domElement.style.width = '300px';
            this.domElement.style.height = '150px';
            this.domElement.style.display = 'block';
            this._ctx = this.domElement.getContext('2d', { alpha: !!params.alpha });
            this._pixelRatio = 1;
            this._width = 300;
            this._height = 150;
            this._clearStyle = 'rgba(0,0,0,0)';
            this.outputEncoding = THREE.LinearEncoding;
        }
        setSize(width, height, updateStyle = true) {
            this._width = width;
            this._height = height;
            const w = Math.max(1, Math.floor(width * this._pixelRatio));
            const h = Math.max(1, Math.floor(height * this._pixelRatio));
            this.domElement.width = w;
            this.domElement.height = h;
            if (updateStyle !== false) {
                this.domElement.style.width = `${width}px`;
                this.domElement.style.height = `${height}px`;
            }
        }
        setPixelRatio(ratio) {
            if (ratio <= 0 || !Number.isFinite(ratio)) {
                return;
            }
            this._pixelRatio = ratio;
            this.setSize(this._width, this._height, false);
        }
        setClearColor(color, alpha = 1) {
            const c = new Color(color);
            this._clearStyle = c.getStyle(alpha);
        }
        dispose() {
            this._ctx = null;
            this.domElement = null;
        }
        _computeCameraBasis(camera) {
            const target = (camera && camera.__controlTarget) ? camera.__controlTarget : new Vector3();
            const position = camera.position.clone();
            const forward = target.clone().sub(position);
            if (forward.lengthSq() === 0) {
                forward.set(0, 0, -1);
            }
            forward.normalize();
            const up = camera.up ? camera.up.clone().normalize() : new Vector3(0, 1, 0);
            const right = new Vector3().crossVectors(forward, up);
            if (right.lengthSq() === 0) {
                right.set(1, 0, 0);
            } else {
                right.normalize();
            }
            const trueUp = new Vector3().crossVectors(right, forward).normalize();
            return { position, target, forward, right, up: trueUp };
        }
        render(scene, camera) {
            if (!this._ctx || !scene || !camera) {
                return;
            }
            const ctx = this._ctx;
            const pixelRatio = this._pixelRatio;
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.fillStyle = this._clearStyle;
            ctx.fillRect(0, 0, this.domElement.width, this.domElement.height);
            ctx.restore();
            ctx.save();
            ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
            ctx.clearRect(0, 0, this._width, this._height);
            ctx.fillStyle = this._clearStyle;
            ctx.fillRect(0, 0, this._width, this._height);

            const basis = this._computeCameraBasis(camera);
            const { position: eye, forward, right, up } = basis;
            const aspect = camera.aspect || (this._width / this._height);
            const near = camera.near || 0.1;
            const far = camera.far || 2000;
            const items = [];
            THREE.__pickCache = new Map();
            scene.traverse(object => {
                if (!object.visible) {
                    return;
                }
                if (object.isPoints) {
                    const geometry = object.geometry;
                    const material = object.material || new PointsMaterial();
                    if (!geometry || typeof geometry.getAttribute !== 'function') {
                        return;
                    }
                    const positionAttr = geometry.getAttribute('position');
                    if (!positionAttr || !positionAttr.array || !positionAttr.array.length) {
                        return;
                    }
                    const worldPosition = object.getWorldPosition(new Vector3());
                    const worldScale = object.getWorldScale(new Vector3());
                    const centerVector = worldPosition.clone().sub(eye);
                    const centerZ = centerVector.dot(forward);
                    const colorsAttr = geometry.getAttribute('color');
                    items.push({
                        object,
                        type: 'points',
                        positions: positionAttr.array,
                        positionItemSize: positionAttr.itemSize || 3,
                        colors: colorsAttr && colorsAttr.array ? colorsAttr.array : null,
                        color: material.color ? material.color.clone() : new Color(0xffffff),
                        vertexColors: !!material.vertexColors,
                        size: material.size !== undefined ? material.size : 1,
                        sizeAttenuation: material.sizeAttenuation !== undefined ? material.sizeAttenuation : true,
                        opacity: material.transparent ? material.opacity : 1,
                        worldPosition,
                        worldScale,
                        distance: worldPosition.distanceTo(eye),
                        ndcZ: centerZ,
                        renderOrder: object.renderOrder || 0
                    });
                    return;
                }
                if (!object.isMesh && !object.isSprite) {
                    return;
                }
                const worldPosition = object.getWorldPosition(new Vector3());
                const toPoint = worldPosition.clone().sub(eye);
                const z = toPoint.dot(forward);
                if (z <= near || z >= far) {
                    return;
                }
                const halfHeight = z * Math.tan((camera.fov * DEG2RAD) / 2);
                const halfWidth = halfHeight * aspect;
                if (halfHeight <= 0 || halfWidth <= 0) {
                    return;
                }
                const xComponent = toPoint.dot(right);
                const yComponent = toPoint.dot(up);
                const ndcX = xComponent / halfWidth;
                const ndcY = yComponent / halfHeight;
                if (ndcX < -1.5 || ndcX > 1.5 || ndcY < -1.5 || ndcY > 1.5) {
                    // outside view frustum
                }
                const screenX = (ndcX * 0.5 + 0.5) * this._width;
                const screenY = (-ndcY * 0.5 + 0.5) * this._height;
                const distance = worldPosition.distanceTo(eye);
                if (object.isMesh) {
                    const geometry = object.geometry || {};
                    const params = geometry.parameters || {};
                    const scale = object.getWorldScale(new Vector3());
                    let entry = null;
                    if (geometry.type === 'RingGeometry') {
                        const inner = (params.innerRadius || 0) * (scale.x + scale.y) / 2;
                        const outer = (params.outerRadius || 0) * (scale.x + scale.y) / 2;
                        const outerNDC = outer / halfHeight;
                        const innerNDC = inner / halfHeight;
                        const outerPx = outerNDC * this._height * 0.5;
                        const innerPx = innerNDC * this._height * 0.5;
                        items.push({
                            object,
                            type: 'ring',
                            screenX,
                            screenY,
                            outerPx,
                            innerPx,
                            outerNDC,
                            innerNDC,
                            ndcX,
                            ndcY,
                            ndcZ: z,
                            distance,
                            renderOrder: object.renderOrder || 0
                        });
                        entry = {
                            type: 'ring',
                            ndcX,
                            ndcY,
                            outerRadiusNDC: Math.abs(outerNDC),
                            innerRadiusNDC: Math.abs(innerNDC),
                            distance,
                            worldPosition
                        };
                    } else if (geometry.type === 'PlaneGeometry') {
                        const widthParam = params.width !== undefined ? params.width : 1;
                        const heightParam = params.height !== undefined ? params.height : 1;
                        const halfWidthWorld = Math.abs(widthParam * scale.x) * 0.5;
                        const halfHeightWorld = Math.abs(heightParam * scale.y) * 0.5;
                        const widthNDC = halfWidthWorld / halfWidth;
                        const heightNDC = halfHeightWorld / halfHeight;
                        const halfWidthPx = Math.abs(widthNDC) * this._width * 0.5;
                        const halfHeightPx = Math.abs(heightNDC) * this._height * 0.5;
                        items.push({
                            object,
                            type: 'plane',
                            screenX,
                            screenY,
                            halfWidthPx,
                            halfHeightPx,
                            widthNDC,
                            heightNDC,
                            ndcX,
                            ndcY,
                            ndcZ: z,
                            distance,
                            renderOrder: object.renderOrder || 0
                        });
                        entry = {
                            type: 'sphere',
                            ndcX,
                            ndcY,
                            radiusNDC: Math.max(Math.abs(widthNDC), Math.abs(heightNDC)),
                            distance,
                            worldPosition
                        };
                    } else {
                        const radius = (params.radius || 1) * (scale.x + scale.y + scale.z) / 3;
                        const radiusNDC = radius / halfHeight;
                        const radiusPx = radiusNDC * this._height * 0.5;
                        items.push({
                            object,
                            type: 'sphere',
                            screenX,
                            screenY,
                            radiusPx,
                            radiusNDC,
                            ndcX,
                            ndcY,
                            ndcZ: z,
                            distance,
                            renderOrder: object.renderOrder || 0
                        });
                        entry = {
                            type: 'sphere',
                            ndcX,
                            ndcY,
                            radiusNDC: Math.abs(radiusNDC),
                            distance,
                            worldPosition
                        };
                    }
                    if (entry) {
                        THREE.__pickCache.set(object, entry);
                    }
                } else if (object.isSprite) {
                    const scale = object.getWorldScale(new Vector3());
                    const widthWorld = scale.x;
                    const heightWorld = scale.y;
                    const widthNDC = widthWorld / halfWidth;
                    const heightNDC = heightWorld / halfHeight;
                    const widthPx = widthNDC * this._width * 0.5;
                    const heightPx = heightNDC * this._height * 0.5;
                    items.push({
                        object,
                        type: 'sprite',
                        screenX,
                        screenY,
                        widthPx,
                        heightPx,
                        ndcX,
                        ndcY,
                        ndcZ: z,
                        distance,
                        renderOrder: object.renderOrder || 0
                    });
                }
            });

            items.sort((a, b) => {
                if (a.renderOrder !== b.renderOrder) {
                    return a.renderOrder - b.renderOrder;
                }
                return b.ndcZ - a.ndcZ;
            });

            items.forEach(item => {
                if (item.type === 'sphere') {
                    const material = item.object.material || new MeshStandardMaterial();
                    const opacity = material.transparent ? material.opacity : 1;
                    const baseColor = material.color ? material.color.clone() : new Color(0xffffff);
                    const emissive = material.emissive ? material.emissive.clone() : new Color(0x000000);
                    if (material.emissiveIntensity) {
                        emissive.multiplyScalar(material.emissiveIntensity);
                        baseColor.add(emissive);
                    }
                    ctx.beginPath();
                    ctx.arc(item.screenX, item.screenY, Math.max(0, item.radiusPx), 0, Math.PI * 2);
                    ctx.fillStyle = baseColor.getStyle(opacity);
                    ctx.fill();
                } else if (item.type === 'ring') {
                    const material = item.object.material || new MeshBasicMaterial();
                    const opacity = material.transparent ? material.opacity : 1;
                    const color = material.color ? material.color.clone() : new Color(0xffffff);
                    const outerRadius = Math.max(0, item.outerPx);
                    const innerRadius = Math.max(0, item.innerPx);
                    ctx.beginPath();
                    ctx.arc(item.screenX, item.screenY, outerRadius, 0, Math.PI * 2, false);
                    ctx.arc(item.screenX, item.screenY, innerRadius, 0, Math.PI * 2, true);
                    ctx.closePath();
                    ctx.fillStyle = color.getStyle(opacity);
                    ctx.globalAlpha = opacity;
                    ctx.fill();
                    ctx.globalAlpha = 1;
                } else if (item.type === 'plane') {
                    const material = item.object.material || new MeshBasicMaterial();
                    const opacity = material.transparent ? material.opacity : 1;
                    const color = material.color ? material.color.clone() : new Color(0xffffff);
                    const widthPx = Math.max(0, item.halfWidthPx);
                    const heightPx = Math.max(0, item.halfHeightPx);
                    ctx.save();
                    ctx.globalAlpha = opacity;
                    ctx.beginPath();
                    ctx.ellipse(item.screenX, item.screenY, widthPx, heightPx, 0, 0, Math.PI * 2);
                    ctx.clip();
                    if (material.map && material.map.image) {
                        ctx.drawImage(
                            material.map.image,
                            item.screenX - widthPx,
                            item.screenY - heightPx,
                            widthPx * 2,
                            heightPx * 2
                        );
                    } else {
                        ctx.fillStyle = color.getStyle(opacity);
                        ctx.fill();
                    }
                    ctx.restore();
                } else if (item.type === 'points') {
                    const positions = item.positions || [];
                    if (!positions.length) {
                        return;
                    }
                    const step = Math.max(1, item.positionItemSize || 3);
                    const opacity = THREE.MathUtils.clamp(item.opacity !== undefined ? item.opacity : 1, 0, 1);
                    const baseStyle = item.vertexColors ? null : item.color.getStyle(opacity);
                    const scale = item.worldScale || new Vector3(1, 1, 1);
                    const basePosition = item.worldPosition || new Vector3();
                    const colors = item.vertexColors ? (item.colors || null) : null;
                    const world = new Vector3();
                    const toPointVec = new Vector3();
                    for (let i = 0; i <= positions.length - step; i += step) {
                        const px = positions[i];
                        const py = step > 1 ? positions[i + 1] : 0;
                        const pz = step > 2 ? positions[i + 2] : 0;
                        world.copy(basePosition);
                        world.x += px * scale.x;
                        world.y += py * scale.y;
                        world.z += pz * scale.z;
                        toPointVec.subVectors(world, eye);
                        const z = toPointVec.dot(forward);
                        if (z <= near || z >= far) {
                            continue;
                        }
                        const halfHeight = z * Math.tan((camera.fov * DEG2RAD) / 2);
                        const halfWidth = halfHeight * aspect;
                        if (halfHeight <= 0 || halfWidth <= 0) {
                            continue;
                        }
                        const ndcX = toPointVec.dot(right) / halfWidth;
                        const ndcY = toPointVec.dot(up) / halfHeight;
                        if (ndcX < -1.5 || ndcX > 1.5 || ndcY < -1.5 || ndcY > 1.5) {
                            continue;
                        }
                        const screenX = (ndcX * 0.5 + 0.5) * this._width;
                        const screenY = (-ndcY * 0.5 + 0.5) * this._height;
                        const attenuation = item.sizeAttenuation ? Math.max(0.4, 140 / Math.max(z, 1)) : 1;
                        const radiusPx = Math.max(0.5, item.size * attenuation);
                        let fillStyle = baseStyle;
                        if (colors) {
                            const baseIndex = i;
                            const r = THREE.MathUtils.clamp(colors[baseIndex] || 0, 0, 1);
                            const g = THREE.MathUtils.clamp(colors[baseIndex + 1] || 0, 0, 1);
                            const b = THREE.MathUtils.clamp(colors[baseIndex + 2] || 0, 0, 1);
                            fillStyle = `rgba(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)}, ${opacity})`;
                        }
                        ctx.beginPath();
                        ctx.arc(screenX, screenY, radiusPx, 0, Math.PI * 2);
                        ctx.fillStyle = fillStyle;
                        ctx.fill();
                    }
                } else if (item.type === 'sprite') {
                    const material = item.object.material || new SpriteMaterial();
                    const map = material.map;
                    if (!map || !map.image) {
                        return;
                    }
                    const opacity = material.transparent ? material.opacity : 1;
                    ctx.save();
                    ctx.globalAlpha = opacity;
                    ctx.drawImage(
                        map.image,
                        item.screenX - item.widthPx * (item.object.center.x),
                        item.screenY - item.heightPx * (item.object.center.y),
                        item.widthPx,
                        item.heightPx
                    );
                    ctx.restore();
                }
            });

            ctx.restore();
        }
    }

    THREE.WebGLRenderer = WebGLRenderer;

    THREE.requestAnimationFrame = global.requestAnimationFrame ? global.requestAnimationFrame.bind(global) : function(cb) {
        return setTimeout(cb, 16);
    };

    global.THREE = THREE;
})(typeof window !== 'undefined' ? window : (typeof globalThis !== 'undefined' ? globalThis : this));
